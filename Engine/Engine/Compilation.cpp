#include "Interface.h"
#include "Location.h"
#include "Debug.h"
#include "Project.h"

#include <fstream>

int Compilation()
{
	// Создание папки build
	std::string str = "mkdir \"" + pathProj + "\\build\\\"";
	Debug(str.c_str()); Debug("\n");
	system(str.c_str()); Debug("\n");

	std::ofstream file;

	str = pathProj + "\\scripts\\main.cpp";
	file.open(str);

	if (!file.is_open())
	{
		Debug("Compilation is cancel\n");
		Debug("File main.cpp is not open\n");
	}

	// Копия шаблона в проект
	file << ""
"#define _CRT_SECURE_NO_WARNINGS																		  \n"
"#define GLEW_STATIC																					  \n"
"																										  \n"
"#include <windows.h>																					  \n"
"#include <fstream>																						  \n"
"#include <sstream>																						  \n"
"#include <stdint.h>																					  \n"
"#include <cstring>																						  \n"
"#include <string>																						  \n"
"#include <iostream>																					  \n"
"#include <algorithm>																					  \n"
"																										  \n"
"#include \"include/GLEW/glew.h\"																		  \n"
"																										  \n"
"#include \"bmp.h\"																						  \n"
"																										  \n"
"#include \"include/GLM/glm.hpp\"																		  \n"
"#include \"include/GLM/gtc/matrix_transform.hpp\"														  \n"
"#include \"include/GLM/gtc/type_ptr.hpp\"																  \n"
"																										  \n"
"#define VK_0						0x30																  \n"
"#define VK_1						0x31																  \n"
"#define VK_2						0x32																  \n"
"#define VK_3						0x33																  \n"
"#define VK_4						0x34																  \n"
"#define VK_5						0x35																  \n"
"#define VK_6						0x36																  \n"
"#define VK_7						0x37																  \n"
"#define VK_8						0x38																  \n"
"#define VK_9						0x39																  \n"
"																										  \n"
"#define VK_A						0x41																  \n"
"#define VK_B						0x42																  \n"
"#define VK_C						0x43																  \n"
"#define VK_D						0x44																  \n"
"#define VK_E						0x45																  \n"
"#define VK_F						0x46																  \n"
"#define VK_G						0x47																  \n"
"#define VK_H						0x48																  \n"
"#define VK_I						0x49																  \n"
"#define VK_J						0x4A																  \n"
"#define VK_K						0x4B																  \n"
"#define VK_L						0x4C																  \n"
"#define VK_M						0x4D																  \n"
"#define VK_N						0x4E																  \n"
"#define VK_O						0x4F																  \n"
"#define VK_P						0x50																  \n"
"#define VK_Q						0x51																  \n"
"#define VK_R						0x52																  \n"
"#define VK_S						0x53																  \n"
"#define VK_T						0x54																  \n"
"#define VK_U						0x55																  \n"
"#define VK_V						0x56																  \n"
"#define VK_W						0x57																  \n"
"#define VK_X						0x58																  \n"
"#define VK_Y						0x59																  \n"
"#define VK_Z						0x5A																  \n"


"// Определяет несколько возможных вариантов движения камеры. Используется как абстракция.														   \n"
"enum Camera_Movement {																															   \n"
"FORWARD,																																		   \n"
"BACKWARD,																																		   \n"
"LEFT,																																			   \n"
"RIGHT																																			   \n"
"};																																				   \n"
"																																				   \n"
"// Стандартные значения камеры																													   \n"
"const GLfloat YAW = -90.0f;																													   \n"
"const GLfloat PITCH = 0.0f;																													   \n"
"const GLfloat SPEED = 10.0f;																													   \n"
"const GLfloat SENSITIVTY = 0.25f;																												   \n"
"const GLfloat ZOOM = 45.0f;																													   \n"
"																																				   \n"
"																																				   \n"
"// Абстрактный класс камеры, который обрабатывает ввод и вычисляет соответствующие Eular Angles, Vectors и Matrices для использования в OpenGL	   \n"
"class Camera																																	   \n"
"{																																				   \n"
"public:																																		   \n"
"// Аттрибуты камеры																															   \n"
"glm::vec3 Position;																															   \n"
"glm::vec3 Front;																																   \n"
"glm::vec3 Up;																																	   \n"
"glm::vec3 Right;																																   \n"
"																																				   \n"
"// Углы Эйлера																																	   \n"
"GLfloat Yaw;																																	   \n"
"GLfloat Pitch;																																	   \n"
"																																				   \n"
"// Опции камеры																																   \n"
"GLfloat MovementSpeed;																															   \n"
"GLfloat MouseSensitivity;																														   \n"
"GLfloat Zoom;																																	   \n"
"																																				   \n"
"// Конструктор камеры через вектора																											   \n"
"Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), GLfloat yaw = YAW, GLfloat pitch = PITCH)												   \n"
": Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVTY), Zoom(ZOOM)											   \n"
"{																																				   \n"
"this->Position = position;																														   \n"
"this->Yaw = yaw;																																   \n"
"this->Pitch = pitch;																															   \n"
"this->updateCameraVectors();																													   \n"
"}																																				   \n"
"																																				   \n"
"// Просмотр матрицы																															   \n"
"glm::mat4 GetViewMatrix()																														   \n"
"{																																				   \n"
"//Возвращаем направления взгляда камеры																										   \n"
"return glm::lookAt(this->Position, this->Position + this->Front, this->Up);																	   \n"
"}																																				   \n"
"																																				   \n"
"// обрабатывает ввод, полученный от любой системы ввода с клавиатуры. Принимает входной параметр в виде камеры, определенной ENUM				   \n"
"void ProcessKeyboard(Camera_Movement direction, GLfloat deltaTime)																				   \n"
"{																																				   \n"
"//обработка движения относительно полученной enum переменной. Через enum чтобы абстрагироваться												   \n"
"GLfloat velocity = this->MovementSpeed * deltaTime;																							   \n"
"if (direction == FORWARD)																														   \n"
"this->Position += this->Front * velocity;																										   \n"
"if (direction == BACKWARD)																														   \n"
"this->Position -= this->Front * velocity;																										   \n"
"if (direction == LEFT)																															   \n"
"this->Position -= this->Right * velocity;																										   \n"
"if (direction == RIGHT)																														   \n"
"this->Position += this->Right * velocity;																										   \n"
"}																																				   \n"
"																																				   \n"
"// Процессы ввода, полученные от системы ввода. Ожидает значение смещения как в направлении x, так и в направлении y.							   \n"
"void ProcessMouseMovement(GLfloat xoffset, GLfloat yoffset, GLboolean constrainPitch = true)													   \n"
"{																																				   \n"
"//изменяем тангаж и рысканье относительно движения мыши																						   \n"
"xoffset *= this->MouseSensitivity;																												   \n"
"yoffset *= this->MouseSensitivity;																												   \n"
"																																				   \n"
"this->Yaw += xoffset;																															   \n"
"this->Pitch += yoffset;																														   \n"
"																																				   \n"
"// Условие для того чтобы экран не перевернулся																								   \n"
"if (constrainPitch)																															   \n"
"{																																				   \n"
"if (this->Pitch > 89.0f)																														   \n"
"this->Pitch = 89.0f;																															   \n"
"if (this->Pitch < -89.0f)																														   \n"
"this->Pitch = -89.0f;																															   \n"
"}																																				   \n"
"																																				   \n"
"// Обновить Front, Right и Up векторы с использованием обновленных углов Эйлера																   \n"
"this->updateCameraVectors();																													   \n"
"}																																				   \n"
"																																				   \n"
"// Обработка входных данных, полученных от события прокрутки мыши. Требуется только вход по вертикальной оси колеса							   \n"
"void ProcessMouseScroll(GLfloat yoffset)																										   \n"
"{																																				   \n"
"//Зум который на самом деле угол обзора																										   \n"
"if (this->Zoom >= 44.0f && this->Zoom <= 47.0f)																								   \n"
"this->Zoom -= yoffset / 50.0f;																													   \n"
"if (this->Zoom <= 44.0f)																														   \n"
"this->Zoom = 44.0f;																															   \n"
"if (this->Zoom >= 47.0f)																														   \n"
"this->Zoom = 47.0f;																															   \n"
"}																																				   \n"
"																																				   \n"
"private:																																		   \n"
"// Вычисляет front вектор для обновления углов Эйлера у камеры																					   \n"
"void updateCameraVectors()																														   \n"
"{																																				   \n"
"// Рассчёт нового Front вектора																												   \n"
"glm::vec3 front;																																   \n"
"front.x = cos(glm::radians(this->Yaw)) * cos(glm::radians(this->Pitch));																		   \n"
"front.y = sin(glm::radians(this->Pitch));																										   \n"
"front.z = sin(glm::radians(this->Yaw)) * cos(glm::radians(this->Pitch));																		   \n"
"this->Front = glm::normalize(front);																											   \n"
"// Пересчёт Right и Up векторов																												   \n"
"// Нормализовать векторы, поскольку их длина приближается к 0, чем больше вы смотрите вверх или вниз, что приводит к более медленному движению.   \n"
"this->Right = glm::normalize(glm::cross(this->Front, glm::vec3(0.0f, 1.0f, 0.0f)));															   \n"
"this->Up = glm::normalize(glm::cross(this->Right, this->Front));																				   \n"
"}																																				   \n"
"};																																				   \n"


"																										  \n"
"Camera *camera;																						  \n"
"																										  \n"
"int64_t mouseOffsetX,																					  \n"
"mouseOffsetY,																							  \n"
"lastMousePosX,																							  \n"
"lastMousePosY;																							  \n"
"																										  \n"
"POINT* mousePos;																						  \n"
"																										  \n"
"uint16_t numberOfKeys;																					  \n"
"																										  \n"
"bool* previousKeyboardState;																			  \n"
"																										  \n"


"class Vector															   \n"
"{																		   \n"
"public:																   \n"
"int64_t x, y, z;														   \n"
"																		   \n"
"Vector(int64_t _x, int64_t _y, int64_t _z) : x(_x), y(_y), z(_z)		   \n"
"{																		   \n"
"																		   \n"
"}																		   \n"
"																		   \n"
"Vector(int64_t _x, int64_t _y) : x(_x), y(_y), z(0)					   \n"
"{																		   \n"
"																		   \n"
"}																		   \n"
"																		   \n"
"Vector(int64_t _x) : x(_x), y(0), z(0)									   \n"
"{																		   \n"
"																		   \n"
"}																		   \n"
"																		   \n"
"Vector() : x(0), y(0), z(0)											   \n"
"{																		   \n"
"																		   \n"
"}																		   \n"
"};																		   \n"
"																		   \n"

"class Mesh																   \n"
"{																		   \n"
"public:																   \n"
"																		   \n"
"char					name[256];										   \n"
"																		   \n"
"unsigned int			VAO, VBO;										   \n"
"																		   \n"
"unsigned long long		faces_Count;									   \n"
"																		   \n"
"unsigned int			diffuse_texture, specular_texture, bump_texture;   \n"
"																		   \n"
"Mesh()																	   \n"
"{																		   \n"
"																		   \n"
"}																		   \n"
"																		   \n"
"~Mesh()																   \n"
"{																		   \n"
"glDeleteVertexArrays(1, &VAO);											   \n"
"glDeleteBuffers(1, &VBO);												   \n"
"}																		   \n"
"																		   \n"
"void DrawMesh()														   \n"
"{																		   \n"
"// Текстура															   \n"
"// Материалы и тд и тп													   \n"
"																		   \n"
"glBindVertexArray(VAO);												   \n"
"glBindTexture(GL_TEXTURE_2D, diffuse_texture);							   \n"
"																		   \n"
"glDrawArrays(GL_TRIANGLES, 0, faces_Count);							   \n"
"																		   \n"
"glBindVertexArray(0);													   \n"
"glBindTexture(GL_TEXTURE_2D, 0);										   \n"
"}																		   \n"
"};																		   \n"


"constexpr int StrLen = 512;																							 \n"
"																														 \n"
"uint32_t ImportObj(const char* objPath, const char* dirPath, Mesh* Meshs)												 \n"
"{																														 \n"
"std::ifstream file_obj;																								 \n"
"file_obj.open(objPath, std::ios_base::in);																				 \n"
"																														 \n"
"// Строка для временных операций																						 \n"
"char str[StrLen];																										 \n"
"																														 \n"
"// Имя файла библиотеки материалов																						 \n"
"char mtllib[StrLen];																									 \n"
"																														 \n"
"// Количество полигонов																								 \n"
"unsigned int faces_count(0);																							 \n"
"																														 \n"
"// Количество вершин																									 \n"
"unsigned int vertices_v_count(0);																						 \n"
"// Количество текстурных вершин																						 \n"
"unsigned int vertices_vt_count(0);																						 \n"
"// Количество нормалей вершин																							 \n"
"unsigned int vertices_vn_count(0);																						 \n"
"																														 \n"
"// Инициализация названий других файлов и количества вершин															 \n"
"while (!file_obj.eof())																								 \n"
"{																														 \n"
"file_obj >> str;																										 \n"
"																														 \n"
"if (strlen(str) == 6)																									 \n"
"{																														 \n"
"if (strcmp(str, \"mtllib\") == 0)																						 \n"
"{																														 \n"
"file_obj >> str;																										 \n"
"strcpy(mtllib, str);																									 \n"
"}																														 \n"
"}																														 \n"
"else if (strlen(str) == 1)																								 \n"
"{																														 \n"
"if (strcmp(str, \"f\") == 0)																							 \n"
"{																														 \n"
"++faces_count;																											 \n"
"}																														 \n"
"else if (strcmp(str, \"v\") == 0)																						 \n"
"{																														 \n"
"++vertices_v_count;																									 \n"
"}																														 \n"
"}																														 \n"
"else if (strlen(str) == 2)																								 \n"
"{																														 \n"
"if (strcmp(str, \"vt\") == 0)																							 \n"
"{																														 \n"
"++vertices_vt_count;																									 \n"
"}																														 \n"
"else if (strcmp(str, \"vn\") == 0)																						 \n"
"{																														 \n"
"++vertices_vn_count;																									 \n"
"}																														 \n"
"}																														 \n"
"file_obj.getline(str, StrLen);																							 \n"
"}																														 \n"
"																														 \n"
"file_obj.close();																										 \n"
"																														 \n"
"faces_count *= 3;																										 \n"
"																														 \n"
"vertices_v_count *= 3;																									 \n"
"vertices_vt_count *= 2;																								 \n"
"vertices_vn_count *= 3;																								 \n"
"																														 \n"
"// Временный массив вершин																								 \n"
"float* vertices_v_temp = new float[vertices_v_count];																	 \n"
"// Временный массив вершин текстурных																					 \n"
"float* vertices_vt_temp = new float[vertices_vt_count];																 \n"
"// Временный массив вершин нормалей																					 \n"
"float* vertices_vn_temp = new float[vertices_vn_count];																 \n"
"																														 \n"
"// Временный массив индексов																							 \n"
"unsigned int* faces_v_temp = new unsigned int[faces_count];															 \n"
"// Временный массив индексов текстурных																				 \n"
"unsigned int* faces_vt_temp = new unsigned int[faces_count];															 \n"
"// Временный массив индексов нормалей																					 \n"
"unsigned int* faces_vn_temp = new unsigned int[faces_count];															 \n"
"																														 \n"
"// Создание пути к mtllib																								 \n"
"char mtllibPath[StrLen];																								 \n"
"strcpy(mtllibPath, dirPath);																							 \n"
"strcat(mtllibPath, \"/\");																								 \n"
"strcat(mtllibPath, mtllib);																							 \n"
"																														 \n"
"file_obj.open(objPath, std::ios_base::in);																				 \n"
"unsigned int iv_v(0);	// Итератор вершин																				 \n"
"unsigned int iv_vt(0);	// Итератор вершин текстурных																	 \n"
"unsigned int iv_vn(0);	// Итератор вершин нормалей																		 \n"
"unsigned int iv_f(0);	// Итератор индексов																			 \n"
"long int io_o(-1);	// Итератор объектов																				 \n"
"																														 \n"
"while (!file_obj.eof())																								 \n"
"{																														 \n"
"file_obj >> str;																										 \n"
"																														 \n"
"if (strlen(str) == 1)																									 \n"
"{																														 \n"
"if (strcmp(str, \"v\") == 0)																							 \n"
"{																														 \n"
"file_obj >> str;																										 \n"
"vertices_v_temp[iv_v] = std::stof(str); ++iv_v;																		 \n"
"file_obj >> str;																										 \n"
"vertices_v_temp[iv_v] = std::stof(str); ++iv_v;																		 \n"
"file_obj >> str;																										 \n"
"vertices_v_temp[iv_v] = std::stof(str); ++iv_v;																		 \n"
"}																														 \n"
"else if (strcmp(str, \"f\") == 0)																						 \n"
"{																														 \n"
"file_obj.getline(str, StrLen);																							 \n"
"if (strchr(str, 47) != NULL)																							 \n"
"{																														 \n"
"char* str_temp = strtok(str, \"/ \");																					 \n"
"faces_v_temp[iv_f] = std::stoi(str_temp) - 1;																			 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_vt_temp[iv_f] = std::stoi(str_temp) - 1;																			 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_vn_temp[iv_f] = std::stoi(str_temp) - 1; ++iv_f;																	 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_v_temp[iv_f] = std::stoi(str_temp) - 1;																			 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_vt_temp[iv_f] = std::stoi(str_temp) - 1;																			 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_vn_temp[iv_f] = std::stoi(str_temp) - 1; ++iv_f;																	 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_v_temp[iv_f] = std::stoi(str_temp) - 1;																			 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_vt_temp[iv_f] = std::stoi(str_temp) - 1;																			 \n"
"str_temp = strtok(NULL, \"/ \");																						 \n"
"faces_vn_temp[iv_f] = std::stoi(str_temp) - 1; ++iv_f;																	 \n"
"																														 \n"
"continue; // Необходимо для того чтобы не бралась ещё одна строка в конце общего цикла									 \n"
"}																														 \n"
"else																													 \n"
"{																														 \n"
"for (int i = 0; i < 3; i++)																							 \n"
"{																														 \n"
"// На случай если f не разделенеы \"/\"																				 \n"
"}																														 \n"
"}																														 \n"
"																														 \n"
"}																														 \n"
"else if (strcmp(str, \"o\") == 0)																						 \n"
"{																														 \n"
"if (io_o != -1)																										 \n"
"{																														 \n"
"// Идёт переназначение массивов вершин относительно индексов															 \n"
"unsigned int j(0);																										 \n"
"																														 \n"
"// Итоговый массив вершин																								 \n"
"float* vertices = new float[iv_f * 2 + iv_f * 3 + iv_f * 3];															 \n"
"																														 \n"
"for (int i = 0; i < iv_f; i++)																							 \n"
"{																														 \n"
"uint64_t t = faces_v_temp[i] + 1;																						 \n"
"vertices[j] = vertices_v_temp[t * 3 - 3]; j++;																			 \n"
"vertices[j] = vertices_v_temp[t * 3 - 2]; j++;																			 \n"
"vertices[j] = vertices_v_temp[t * 3 - 1]; j++;																			 \n"
"}																														 \n"
"																														 \n"
"j = 0;																													 \n"
"																														 \n"
"for (int i = 0; i < iv_f; i++)																							 \n"
"{																														 \n"
"uint64_t t = faces_vt_temp[i] + 1;																						 \n"
"vertices[(iv_f * 3) + j] = vertices_vt_temp[t * 2 - 2]; j++;															 \n"
"vertices[(iv_f * 3) + j] = vertices_vt_temp[t * 2 - 1]; j++;															 \n"
"}																														 \n"
"																														 \n"
"j = 0;																													 \n"
"																														 \n"
"for (int i = 0; i < iv_f; i++)																							 \n"
"{																														 \n"
"uint64_t t = faces_vn_temp[i] + 1;																						 \n"
"vertices[(iv_f * 3 + iv_f * 2) + j] = vertices_vn_temp[t * 3 - 3]; j++;												 \n"
"vertices[(iv_f * 3 + iv_f * 2) + j] = vertices_vn_temp[t * 3 - 2]; j++;												 \n"
"vertices[(iv_f * 3 + iv_f * 2) + j] = vertices_vn_temp[t * 3 - 1]; j++;												 \n"
"}																														 \n"
"																														 \n"
"// Генерация VAO, VBO																									 \n"
"																														 \n"
"glGenVertexArrays(1, &Meshs[io_o].VAO);																				 \n"
"glGenBuffers(1, &Meshs[io_o].VBO);																						 \n"
"																														 \n"
"glBindVertexArray(Meshs[io_o].VAO);																					 \n"
"																														 \n"
"glBindBuffer(GL_ARRAY_BUFFER, Meshs[io_o].VBO);																		 \n"
"glBufferData(GL_ARRAY_BUFFER, ((iv_f * 2) + (iv_f * 3) + (iv_f * 3)) * sizeof(GLfloat), vertices, GL_STATIC_DRAW);		 \n"
"																														 \n"
"glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);														 \n"
"glEnableVertexAttribArray(0);																							 \n"
"																														 \n"
"glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, (GLvoid*)((iv_f * 3) * sizeof(GLfloat)));							 \n"
"glEnableVertexAttribArray(1);																							 \n"
"																														 \n"
"glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)((iv_f * 3 + iv_f * 2) * sizeof(GLfloat)));				 \n"
"glEnableVertexAttribArray(2);																							 \n"
"																														 \n"
"glBindVertexArray(0);																									 \n"
"																														 \n"
"Meshs[io_o].faces_Count = iv_f;																						 \n"
"																														 \n"
"iv_f = 0;																												 \n"
"																														 \n"
"++io_o;																												 \n"
"}																														 \n"
"else																													 \n"
"{																														 \n"
"io_o = 0;																												 \n"
"}																														 \n"
"}																														 \n"
"}																														 \n"
"else if (strlen(str) == 2)																								 \n"
"{																														 \n"
"if (strcmp(str, \"vt\") == 0)																							 \n"
"{																														 \n"
"file_obj >> str;																										 \n"
"vertices_vt_temp[iv_vt] = std::stof(str); ++iv_vt;																		 \n"
"file_obj >> str;																										 \n"
"vertices_vt_temp[iv_vt] = std::stof(str); ++iv_vt;																		 \n"
"}																														 \n"
"else if (strcmp(str, \"vn\") == 0)																						 \n"
"{																														 \n"
"file_obj >> str;																										 \n"
"vertices_vn_temp[iv_vn] = std::stof(str); ++iv_vn;																		 \n"
"file_obj >> str;																										 \n"
"vertices_vn_temp[iv_vn] = std::stof(str); ++iv_vn;																		 \n"
"file_obj >> str;																										 \n"
"vertices_vn_temp[iv_vn] = std::stof(str); ++iv_vn;																		 \n"
"}																														 \n"
"}																														 \n"
"else if (strlen(str) == 6)																								 \n"
"{																														 \n"
"if (strcmp(str, \"usemtl\") == 0)																						 \n"
"{																														 \n"
"char newmtl[StrLen];																									 \n"
"bool flag_new_material(true);																							 \n"
"file_obj >> newmtl;																									 \n"
"std::ifstream file_mtl;																								 \n"
"file_mtl.open(mtllibPath, std::ios_base::in);																			 \n"
"																														 \n"
"while (flag_new_material && !file_mtl.eof())																			 \n"
"{																														 \n"
"file_mtl >> str;																										 \n"
"if (strlen(str) == 6)																									 \n"
"{																														 \n"
"if (strcmp(str, \"newmtl\") == 0)																						 \n"
"{																														 \n"
"file_mtl >> str;																										 \n"
"if (strcmp(str, newmtl) == 0)																							 \n"
"{																														 \n"
"while (flag_new_material && !file_mtl.eof())																			 \n"
"{																														 \n"
"file_mtl >> str;																										 \n"
"if (strlen(str) == 2)																									 \n"
"{																														 \n"
"if (strcmp(str, \"Ns\") == 0)																							 \n"
"{																														 \n"
"// Коэффициент specular																								 \n"
"}																														 \n"
"else if (strcmp(str, \"Ka\") == 0)																						 \n"
"{																														 \n"
"// ambient																												 \n"
"}																														 \n"
"else if (strcmp(str, \"Kd\") == 0)																						 \n"
"{																														 \n"
"// diffuse																												 \n"
"}																														 \n"
"else if (strcmp(str, \"Ks\") == 0)																						 \n"
"{																														 \n"
"// Цвет specular																										 \n"
"}																														 \n"
"else if (strcmp(str, \"Ke\") == 0)																						 \n"
"{																														 \n"
"// emissive																											 \n"
"}																														 \n"
"else if (strcmp(str, \"Ni\") == 0)																						 \n"
"{																														 \n"
"// если честно не знаю что это																							 \n"
"}																														 \n"
"}																														 \n"
"else if (strlen(str) == 1)																								 \n"
"{																														 \n"
"if (strcmp(str, \"d\") == 0)																							 \n"
"{																														 \n"
"// Прозрачность																										 \n"
"}																														 \n"
"}																														 \n"
"else if (strlen(str) == 6)																								 \n"
"{																														 \n"
"if (strcmp(str, \"map_Kd\") == 0)																						 \n"
"{																														 \n"
"unsigned int texture;																									 \n"
"int h, w;																												 \n"
"file_mtl >> str;																										 \n"
"char texture_Path[StrLen];																								 \n"
"strcpy(texture_Path, dirPath);																							 \n"
"strcat(texture_Path, \"/\");																							 \n"
"strcat(texture_Path, str);																								 \n"
"unsigned char* image = bmp_reader(texture_Path, h, w);																	 \n"
"																														 \n"
"glGenTextures(1, &texture);																							 \n"
"glBindTexture(GL_TEXTURE_2D, texture);																					 \n"
"																														 \n"
"glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);															 \n"
"glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);															 \n"
"																														 \n"
"glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);														 \n"
"glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);														 \n"
"																														 \n"
"glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, image);									 \n"
"glGenerateMipmap(GL_TEXTURE_2D);																						 \n"
"glBindTexture(GL_TEXTURE_2D, 0);																						 \n"
"free(image);																											 \n"
"																														 \n"
"Meshs[io_o].diffuse_texture = texture;																					 \n"
"}																														 \n"
"else if (strcmp(str, \"newmtl\") == 0)																					 \n"
"{																														 \n"
"flag_new_material = false;																								 \n"
"}																														 \n"
"}																														 \n"
"file_mtl.getline(str, StrLen);																							 \n"
"}																														 \n"
"}																														 \n"
"}																														 \n"
"}																														 \n"
"file_mtl.getline(str, StrLen);																							 \n"
"}																														 \n"
"}																														 \n"
"}																														 \n"
"file_obj.getline(str, StrLen);																							 \n"
"if (file_obj.eof())																									 \n"
"{																														 \n"
"// Идёт переназначение массивов вершин относительно индексов															 \n"
"unsigned int j(0);																										 \n"
"																														 \n"
"// Итоговый массив вершин																								 \n"
"float* vertices = new float[iv_f * 2 + iv_f * 3 + iv_f * 3];															 \n"
"																														 \n"
"for (int i = 0; i < iv_f; i++)																							 \n"
"{																														 \n"
"uint64_t t = faces_v_temp[i] + 1;																						 \n"
"vertices[j] = vertices_v_temp[t * 3 - 3]; j++;																			 \n"
"vertices[j] = vertices_v_temp[t * 3 - 2]; j++;																			 \n"
"vertices[j] = vertices_v_temp[t * 3 - 1]; j++;																			 \n"
"}																														 \n"
"																														 \n"
"j = 0;																													 \n"
"																														 \n"
"for (int i = 0; i < iv_f; i++)																							 \n"
"{																														 \n"
"uint64_t t = faces_vt_temp[i] + 1;																						 \n"
"vertices[(iv_f * 3) + j] = vertices_vt_temp[t * 2 - 2]; j++;															 \n"
"vertices[(iv_f * 3) + j] = vertices_vt_temp[t * 2 - 1]; j++;															 \n"
"}																														 \n"
"																														 \n"
"j = 0;																													 \n"
"																														 \n"
"for (int i = 0; i < iv_f; i++)																							 \n"
"{																														 \n"
"uint64_t t = faces_vn_temp[i] + 1;																						 \n"
"vertices[(iv_f * 3 + iv_f * 2) + j] = vertices_vn_temp[t * 3 - 3]; j++;												 \n"
"vertices[(iv_f * 3 + iv_f * 2) + j] = vertices_vn_temp[t * 3 - 2]; j++;												 \n"
"vertices[(iv_f * 3 + iv_f * 2) + j] = vertices_vn_temp[t * 3 - 1]; j++;												 \n"
"}																														 \n"
"																														 \n"
"// Генерация VAO, VBO																									 \n"
"																														 \n"
"glGenVertexArrays(1, &Meshs[io_o].VAO);																				 \n"
"glGenBuffers(1, &Meshs[io_o].VBO);																						 \n"
"																														 \n"
"glBindVertexArray(Meshs[io_o].VAO);																					 \n"
"																														 \n"
"glBindBuffer(GL_ARRAY_BUFFER, Meshs[io_o].VBO);																		 \n"
"glBufferData(GL_ARRAY_BUFFER, ((iv_f * 2) + (iv_f * 3) + (iv_f * 3)) * sizeof(GLfloat), vertices, GL_STATIC_DRAW);		 \n"
"																														 \n"
"glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)0);														 \n"
"glEnableVertexAttribArray(0);																							 \n"
"																														 \n"
"glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, (GLvoid*)((iv_f * 3) * sizeof(GLfloat)));							 \n"
"glEnableVertexAttribArray(1);																							 \n"
"																														 \n"
"glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (GLvoid*)((iv_f * 3 + iv_f * 2) * sizeof(GLfloat)));				 \n"
"glEnableVertexAttribArray(2);																							 \n"
"																														 \n"
"glBindVertexArray(0);																									 \n"
"																														 \n"
"Meshs[io_o].faces_Count = iv_f;																						 \n"
"																														 \n"
"iv_f = 0;																												 \n"
"																														 \n"
"++io_o;																												 \n"
"}																														 \n"
"}																														 \n"
"file_obj.close();																										 \n"
"																														 \n"
"return 1;																												 \n"
"}																														 \n"


"class Shader																		 \n"
"{																					 \n"
"public:																			 \n"
"unsigned int ID;																	 \n"
"Shader(const char* vertexPath, const char* fragmentPath,							 \n"
"const char* geometryPath = nullptr)												 \n"
"{																					 \n"
"// 1. Получаем исходный код вершины / фрагмента из filePath						 \n"
"std::string vertexCode,															 \n"
"fragmentCode,																		 \n"
"geometryCode;																		 \n"
"																					 \n"
"std::ifstream	vShaderFile,														 \n"
"fShaderFile,																		 \n"
"gShaderFile;																		 \n"
"																					 \n"
"// Убедитесь, что объекты потока могут генерировать исключения:					 \n"
"vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);			 \n"
"fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);			 \n"
"gShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);			 \n"
"																					 \n"
"try																				 \n"
"{																					 \n"
"// Открываем файл																	 \n"
"vShaderFile.open(vertexPath);														 \n"
"fShaderFile.open(fragmentPath);													 \n"
"																					 \n"
"std::stringstream	vShaderStream,													 \n"
"fShaderStream;																		 \n"
"																					 \n"
"// Читаем содержимое файла в потоки												 \n"
"vShaderStream << vShaderFile.rdbuf();												 \n"
"fShaderStream << fShaderFile.rdbuf();												 \n"
"																					 \n"
"// Закрываем файлы																	 \n"
"vShaderFile.close();																 \n"
"fShaderFile.close();																 \n"
"																					 \n"
"// Конвертируем потоки в string													 \n"
"vertexCode = vShaderStream.str();													 \n"
"fragmentCode = fShaderStream.str();												 \n"
"																					 \n"
"// Если путь к геометрическому шейдеру указан, то подгружаем его исходники			 \n"
"if (geometryPath != nullptr)														 \n"
"{																					 \n"
"gShaderFile.open(geometryPath);													 \n"
"std::stringstream gShaderStream;													 \n"
"gShaderStream << gShaderFile.rdbuf();												 \n"
"gShaderFile.close();																 \n"
"geometryCode = gShaderStream.str();												 \n"
"}																					 \n"
"}																					 \n"
"catch (std::ifstream::failure e)													 \n"
"{																					 \n"
"//Debug(\"Exception processed\\n\");												 \n"
"//Debug(\"One of the shader files is unavailable or errors have occurred\\n\");	 \n"
"}																					 \n"
"																					 \n"
"const char* vShaderCode = vertexCode.c_str(),										 \n"
"* fShaderCode = fragmentCode.c_str();												 \n"
"																					 \n"
"// 2. Компилируем шейдеры															 \n"
"unsigned int	vertex,																 \n"
"fragment;																			 \n"
"																					 \n"
"// Vertex shader																	 \n"
"vertex = glCreateShader(GL_VERTEX_SHADER);											 \n"
"glShaderSource(vertex, 1, &vShaderCode, NULL);										 \n"
"glCompileShader(vertex);															 \n"
"checkCompileErrors(vertex, \"VERTEX\");											 \n"
"																					 \n"
"// Fragment Shader																	 \n"
"fragment = glCreateShader(GL_FRAGMENT_SHADER);										 \n"
"glShaderSource(fragment, 1, &fShaderCode, NULL);									 \n"
"glCompileShader(fragment);															 \n"
"checkCompileErrors(fragment, \"FRAGMENT\");										 \n"
"																					 \n"
"// Если исходник геометрического шейдера загружен, то компилим и его				 \n"
"unsigned int geometry;																 \n"
"																					 \n"
"if (geometryPath != nullptr)														 \n"
"{																					 \n"
"const char* gShaderCode = geometryCode.c_str();									 \n"
"geometry = glCreateShader(GL_GEOMETRY_SHADER);										 \n"
"glShaderSource(geometry, 1, &gShaderCode, NULL);									 \n"
"glCompileShader(geometry);															 \n"
"checkCompileErrors(geometry, \"GEOMETRY\");										 \n"
"}																					 \n"
"																					 \n"
"// Шедерная программа																 \n"
"ID = glCreateProgram();															 \n"
"glAttachShader(ID, vertex);														 \n"
"glAttachShader(ID, fragment);														 \n"
"																					 \n"
"if (geometryPath != nullptr)														 \n"
"{																					 \n"
"glAttachShader(ID, geometry);														 \n"
"}																					 \n"
"																					 \n"
"glLinkProgram(ID);																	 \n"
"checkCompileErrors(ID, \"PROGRAM\");												 \n"
"																					 \n"
"// Удаляем шейдеры, они больше не нужны, т.к. находятся в шейдерной программе		 \n"
"glDeleteShader(vertex);															 \n"
"glDeleteShader(fragment);															 \n"
"																					 \n"
"if (geometryPath != nullptr)														 \n"
"{																					 \n"
"glDeleteShader(geometry);															 \n"
"}																					 \n"
"}																					 \n"
"																					 \n"
"// activate the shader																 \n"
"void use()																			 \n"
"{																					 \n"
"glUseProgram(ID);																	 \n"
"}																					 \n"
"																					 \n"
"// utility uniform functions														 \n"
"void setUniform(const std::string& name, bool value)								 \n"
"{																					 \n"
"glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);					 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, int value)								 \n"
"{																					 \n"
"glUniform1i(glGetUniformLocation(ID, name.c_str()), value);						 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, float value)								 \n"
"{																					 \n"
"glUniform1f(glGetUniformLocation(ID, name.c_str()), value);						 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, const glm::vec2& value)					 \n"
"{																					 \n"
"glUniform2fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]);				 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, float x, float y)							 \n"
"{																					 \n"
"glUniform2f(glGetUniformLocation(ID, name.c_str()), x, y);							 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, const glm::vec3& value)					 \n"
"{																					 \n"
"glUniform3fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]);				 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, float x, float y, float z)				 \n"
"{																					 \n"
"glUniform3f(glGetUniformLocation(ID, name.c_str()), x, y, z);						 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, const glm::vec4& value)					 \n"
"{																					 \n"
"glUniform4fv(glGetUniformLocation(ID, name.c_str()), 1, &value[0]);				 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, float x, float y, float z, float w)		 \n"
"{																					 \n"
"glUniform4f(glGetUniformLocation(ID, name.c_str()), x, y, z, w);					 \n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, const glm::mat2& mat)						 \n"
"{																					 \n"
"glUniformMatrix2fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, const glm::mat3& mat)						 \n"
"{																					 \n"
"glUniformMatrix3fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n"
"}																					 \n"
"																					 \n"
"void setUniform(const std::string& name, const glm::mat4& mat)						 \n"
"{																					 \n"
"glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &mat[0][0]);\n"
"}																					 \n"
"																					 \n"
"																					 \n"
"private:																			 \n"
"// utility function for checking shader compilation/linking errors.				 \n"
"void checkCompileErrors(GLuint shader, std::string type)							 \n"
"{																					 \n"
"GLint success;																		 \n"
"GLchar infoLog[1024];																 \n"
"if (type != \"PROGRAM\")															 \n"
"{																					 \n"
"glGetShaderiv(shader, GL_COMPILE_STATUS, &success);								 \n"
"if (!success)																		 \n"
"{																					 \n"
"glGetShaderInfoLog(shader, 1024, NULL, infoLog);									 \n"
"																					 \n"
"//Debug(\"SHADER_COMPILATION_ERROR of type: \");									 \n"
"const char* s = type.c_str();														 \n"
"//Debug(s);																		 \n"
"//Debug(\"\\n\");																	 \n"
"//Debug(infoLog);																	 \n"
"}																					 \n"
"}																					 \n"
"else																				 \n"
"{																					 \n"
"glGetProgramiv(shader, GL_LINK_STATUS, &success);									 \n"
"if (!success)																		 \n"
"{																					 \n"
"glGetProgramInfoLog(shader, 1024, NULL, infoLog);									 \n"
"//Debug(\"SHADER_COMPILATION_ERROR of type: \");									 \n"
"const char* s = type.c_str();														 \n"
"//Debug(s);																		 \n"
"//Debug(\"\\n\");																	 \n"
"//Debug(infoLog);																	 \n"
"}																					 \n"
"}																					 \n"
"}																					 \n"
"};																					 \n"


"class GameObject																										 \n"
"{																														 \n"
"private:																												 \n"
"Vector* p_location;																									 \n"
"Vector* p_rotation;																									 \n"
"Vector* p_scale;																										 \n"
"																														 \n"
"public:																												 \n"
"GLuint		VAO, VBO, EBO;																								 \n"
"																														 \n"
"uint64_t	Vcount, Fcount;																								 \n"
"																														 \n"
"Shader* shader, * selectShader;																						 \n"
"																														 \n"
"GLuint		texture;																									 \n"
"																														 \n"
"glm::mat4	model;																										 \n"
"																														 \n"
"Mesh* Meshs;																											 \n"
"																														 \n"
"int obj_count;																											 \n"
"																														 \n"
"bool is_Select;																										 \n"
"																														 \n"
"std::string	path;																									 \n"
"																														 \n"
"char** scriptNames;																									 \n"
"																														 \n"
"GameObject(Shader* _shader, const char* dirPath)																		 \n"
"{																														 \n"
"// Заполняем поле path																									 \n"
"path = dirPath;																										 \n"
"																														 \n"
"// Инициализируем массив с названиями скриптов в файле																	 \n"
"scriptNames = new char* [16];																							 \n"
"																														 \n"
"for (int i(0); i < 16; ++i)																							 \n"
"{																														 \n"
"scriptNames[i] = new char[256];																						 \n"
"}																														 \n"
"																														 \n"
"shader = _shader;																										 \n"
"																														 \n"
"const char* dirName = strrchr(dirPath, 47) + 1;																		 \n"
"char objPath[512];																										 \n"
"strcpy(objPath, dirPath);																								 \n"
"strcat(objPath, \"/\");																								 \n"
"strcat(objPath, dirName);																								 \n"
"strcat(objPath, \".obj\");																								 \n"
"																														 \n"
"obj_count = 0;																											 \n"
"																														 \n"
"std::ifstream file;																									 \n"
"file.open(objPath, std::ios_base::in);																					 \n"
"if (file.is_open())																									 \n"
"{																														 \n"
"char str[512];																											 \n"
"while (!file.eof())																									 \n"
"{																														 \n"
"file >> str;																											 \n"
"if (strlen(str) == 1)																									 \n"
"{																														 \n"
"if (strcmp(str, \"o\") == 0)																							 \n"
"{																														 \n"
"++obj_count;																											 \n"
"}																														 \n"
"else																													 \n"
"{																														 \n"
"file.getline(str, 512);																								 \n"
"}																														 \n"
"}																														 \n"
"else																													 \n"
"{																														 \n"
"file.getline(str, 512);																								 \n"
"}																														 \n"
"}																														 \n"
"file.close();																											 \n"
"																														 \n"
"Meshs = new Mesh[obj_count];																							 \n"
"																														 \n"
"ImportObj(objPath, dirPath, Meshs);																					 \n"
"																														 \n"
"path = dirName;																										 \n"
"																														 \n"
"//Debug(\"Loading object \"); Debug(dirName); Debug(\" succes\\n\");													 \n"
"}																														 \n"
"else																													 \n"
"{																														 \n"
"//Debug(\"Error loading object \"); Debug(dirName); Debug(\". Invalid path \"); Debug(dirPath); Debug(\"\\n\");		 \n"
"}																														 \n"
"																														 \n"
"is_Select = false;																										 \n"
"}																														 \n"
"																														 \n"
"void setModel(glm::vec3 trans_, glm::vec3 model_, GLfloat degree_, glm::vec3 axis_)									 \n"
"{																														 \n"
"model = glm::mat4(1.0f);																								 \n"
"model = glm::translate(model, model_);																					 \n"
"model = glm::rotate(model, degree_, axis_);																			 \n"
"model = glm::scale(model, trans_);																						 \n"
"}																														 \n"
"																														 \n"
"void Draw(glm::mat4 projection, glm::mat4 view, glm::vec3 viewPos)														 \n"
"{																														 \n"
"shader->use();																											 \n"
"																														 \n"
"//:::::::::::::::::::::::: В Р Е М Е Н Н О :::::::::::::::::::::::::::::::												 \n"
"shader->setUniform(\"material.diffuse\", 0);																			 \n"
"																														 \n"
"shader->setUniform(\"dirLight.direction\", -0.2f, -1.0f, -0.3f);														 \n"
"shader->setUniform(\"dirLight.ambient\", 0.1f, 0.1f, 0.1f);															 \n"
"shader->setUniform(\"dirLight.diffuse\", 0.4f, 0.4f, 0.4f);															 \n"
"shader->setUniform(\"dirLight.specular\", 0.5f, 0.5f, 0.5f);															 \n"
"//:::::::::::::::::::::::: В Р Е М Е Н Н О :::::::::::::::::::::::::::::::												 \n"
"																														 \n"
"shader->setUniform(\"model\", model);																					 \n"
"shader->setUniform(\"projection\", projection);																		 \n"
"shader->setUniform(\"view\", view);																					 \n"
"shader->setUniform(\"viewPos\", viewPos);																				 \n"
"																														 \n"
"for (int i = 0; i < obj_count; i++)																					 \n"
"{																														 \n"
"Meshs[i].DrawMesh();																									 \n"
"}																														 \n"
"																														 \n"
"}																														 \n"
"																														 \n"
"__declspec(property(get = get_location, put = set_location)) Vector location;											 \n"
"__declspec(property(get = get_rotation, put = set_rotation)) Vector rotation;											 \n"
"__declspec(property(get = get_scale, put = set_scale)) Vector scale;													 \n"
"																														 \n"
"Vector& get_location()																									 \n"
"{																														 \n"
"return location;																										 \n"
"}																														 \n"
"																														 \n"
"Vector& get_rotation()																									 \n"
"{																														 \n"
"return rotation;																										 \n"
"}																														 \n"
"																														 \n"
"Vector& get_scale()																									 \n"
"{																														 \n"
"return scale;																											 \n"
"}																														 \n"
"																														 \n"
"void set_location()																									 \n"
"{																														 \n"
"p_location->x = location.x;																							 \n"
"p_location->y = location.y;																							 \n"
"p_location->z = location.z;																							 \n"
"																														 \n"
"// Добавить rotation																									 \n"
"setModel(glm::vec3(scale.x, scale.y, scale.z), glm::vec3(location.x, location.y, location.z), 0.0f, glm::vec3(0, 0, 0));\n"
"}																														 \n"
"																														 \n"
"void set_rotation()																									 \n"
"{																														 \n"
"p_rotation->x = rotation.x;																							 \n"
"p_rotation->y = rotation.y;																							 \n"
"p_rotation->z = rotation.z;																							 \n"
"																														 \n"
"// Добавить rotation																									 \n"
"setModel(glm::vec3(scale.x, scale.y, scale.z), glm::vec3(location.x, location.y, location.z), 0.0f, glm::vec3(0, 0, 0));\n"
"}																														 \n"
"																														 \n"
"void set_scale()																										 \n"
"{																														 \n"
"p_scale->x = scale.x;																									 \n"
"p_scale->y = scale.y;																									 \n"
"p_scale->z = scale.z;																									 \n"
"																														 \n"
"// Добавить rotation																									 \n"
"setModel(glm::vec3(scale.x, scale.y, scale.z), glm::vec3(location.x, location.y, location.z), 0.0f, glm::vec3(0, 0, 0));\n"
"}																														 \n"
"																														 \n"
"~GameObject()																											 \n"
"{																														 \n"
"// Инициализируем массив с названиями скриптов в файле																	 \n"
"scriptNames = new char* [16];																							 \n"
"																														 \n"
"for (int i(0); i < 16; ++i)																							 \n"
"{																														 \n"
"delete[] scriptNames[i];																								 \n"
"}																														 \n"
"																														 \n"
"delete[] scriptNames;																									 \n"
"																														 \n"
"for (int i = 0; i < obj_count; i++)																					 \n"
"{																														 \n"
"Meshs[i].~Mesh();																										 \n"
"}																														 \n"
"}																														 \n"
"};																														 \n"
"																														 \n"
"Shader					*ourShader,						// Шейдер																				   \n"
"* fontShader,					// Шейдер																										   \n"
"* selectShader;					// Шейдер																									   \n"
"LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)						  \n"
"{																										  \n"
"switch (uMsg)																							  \n"
"{																										  \n"
"case WM_DESTROY:																						  \n"
"PostQuitMessage(0);																					  \n"
"break;																									  \n"
"default:																								  \n"
"return DefWindowProc(hwnd, uMsg, wParam, lParam);														  \n"
"}																										  \n"
"																										  \n"
"return 0;																								  \n"
"}																										  \n"
"																										  \n"
"bool isKeyDown(int key)																				  \n"
"{																										  \n"
"return (GetAsyncKeyState(key) & (1 << 16));															  \n"
"}																										  \n"
"																										  \n"
"bool isKeyFirstPressed(int key)																		  \n"
"{																										  \n"
"bool previousState = previousKeyboardState[key];														  \n"
"																										  \n"
"previousKeyboardState[key] = isKeyDown(key);															  \n"
"																										  \n"
"return (previousKeyboardState[key] && !previousState);													  \n"
"}																										  \n"
"																										  \n"
"bool isKeyFirstReleased(int key)																		  \n"
"{																										  \n"
"bool previousState = previousKeyboardState[key];														  \n"
"																										  \n"
"previousKeyboardState[key] = isKeyDown(key);															  \n"
"																										  \n"
"return (!previousKeyboardState[key] && previousState);													  \n"
"}																										  \n"
"																										  \n"
"int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)				  \n"
"{																										  \n"
"if (hPrevInstance)																						  \n"
"{																										  \n"
"MessageBox(NULL, \"Можно запускать только одну копию приложения\", \"Ошибка\", MB_OK | MB_ICONSTOP);	  \n"
"return 1;																								  \n"
"}																										  \n"
"																										  \n"
"camera = new Camera(glm::vec3(0.0f, 0.0f, 15.0f));														  \n"
"																										  \n"
"int16_t windowWidth = GetSystemMetrics(SM_CXSCREEN),													  \n"
"windowHeight = GetSystemMetrics(SM_CYSCREEN);															  \n"
"																										  \n"
"WNDCLASSEX pWndEngineClassEx{};																		  \n"
"																										  \n"
"pWndEngineClassEx.cbSize = sizeof(WNDCLASSEX);															  \n"
"pWndEngineClassEx.style = CS_VREDRAW | CS_HREDRAW;														  \n"
"pWndEngineClassEx.lpfnWndProc = WindowProc;															  \n"
"pWndEngineClassEx.hInstance = hInstance;																  \n"
"pWndEngineClassEx.hCursor = LoadCursor(NULL, IDC_ARROW);												  \n"
"pWndEngineClassEx.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);											  \n"
"pWndEngineClassEx.lpszClassName = \"WndEngineClass\";													  \n"
"pWndEngineClassEx.hIcon = LoadIcon(hInstance, \"IDI_ENGINEICON\");										  \n"
"																										  \n"
"RegisterClassEx(&pWndEngineClassEx);																	  \n"
"																										  \n"
"HWND hWndEngine = CreateWindowEx(WS_EX_ACCEPTFILES,													  \n"
"pWndEngineClassEx.lpszClassName,																		  \n"
"\"Game\", WS_OVERLAPPEDWINDOW | WS_POPUP,																  \n"
"0,																										  \n"
"0,																										  \n"
"windowWidth,																							  \n"
"windowHeight,																							  \n"
"0,																										  \n"
"0,																										  \n"
"hInstance,																								  \n"
"0																										  \n"
");																										  \n"
"																										  \n"
"if (!hWndEngine)																						  \n"
"{																										  \n"
"MessageBox(NULL, \"Window is not create\", \"Error\", MB_OK);											  \n"
"return 1;																								  \n"
"}																										  \n"
"																										  \n"
"ShowWindow(hWndEngine, SW_MAXIMIZE);																	  \n"
"UpdateWindow(hWndEngine);																				  \n"
"																										  \n"
"PIXELFORMATDESCRIPTOR pfd;																				  \n"
"																										  \n"
"int iFormat;																							  \n"
"																										  \n"
"HDC hDC = GetDC(hWndEngine);																			  \n"
"																										  \n"
"ZeroMemory(&pfd, sizeof(pfd));																			  \n"
"																										  \n"
"pfd.nSize = sizeof(pfd);																				  \n"
"pfd.nVersion = 1;																						  \n"
"pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;								  \n"
"pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;								  \n"
"pfd.iPixelType = PFD_TYPE_RGBA;																		  \n"
"pfd.cColorBits = 24;																					  \n"
"pfd.cDepthBits = 16;																					  \n"
"pfd.iLayerType = PFD_MAIN_PLANE;																		  \n"
"																										  \n"
"iFormat = ChoosePixelFormat(hDC, &pfd);																  \n"
"SetPixelFormat(hDC, iFormat, &pfd);																	  \n"
"HGLRC hRC = wglCreateContext(hDC);																		  \n"
"wglMakeCurrent(hDC, hRC);																				  \n"
"																										  \n"
"glewExperimental = GL_TRUE;																			  \n"
"glewInit();																							  \n"
"																										  \n"
"ourShader = new Shader(\"Shader/shader.vs\", \"Shader/shader.fs\");									  \n"
"fontShader = new Shader(\"Shader/FontShader.vs\", \"Shader/FontShader.fs\");							  \n"
"selectShader = new Shader(\"Shader/SelectShader.vs\", \"Shader/SelectShader.fs\");						  \n"
"																										  \n"
"previousKeyboardState = new bool[numberOfKeys];														  \n"
"for (uint16_t keyNum = 0; keyNum < numberOfKeys; ++keyNum)												  \n"
"{																										  \n"
"previousKeyboardState[keyNum] = isKeyDown(keyNum);														  \n"
"}																										  \n"
"																										  \n"
"MSG message{ 0 };																						  \n"
"																										  \n"
"glEnable(GL_DEPTH_TEST);																				  \n"
"glEnable(GL_STENCIL_TEST);																				  \n"
"glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);																  \n"
"																										  \n"
"glViewport(0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));						  \n"
"																										  \n"
"glm::mat4 projection = glm::perspective(camera->Zoom, (GLfloat)windowWidth / windowHeight, 0.1f, 5000.0f),\n"
"ortho = glm::ortho(0.0f, (GLfloat)windowWidth, (GLfloat)windowHeight, 0.0f, 0.0f, 100.0f);				  \n"
"																										  \n"
"mousePos = new POINT();																				  \n";

	// Вставить:
	// int gameobject_count(5);\n
	file << "int gameobject_count("; file << object_list.size(); file << ");\n";

	// Загрузка .obj файлов
	// Вставить:
	// GameObject **objects = new GameObject*[gameobject_count];\n
	file << "GameObject **objects = new GameObject*[gameobject_count];\n";

	for (int i = 0; i < object_list.size(); i++)
	{
		str = std::to_string(i);
		file << "objects[" + str + "] = new GameObject(ourShader, \"Resource/" + object_list[i]->path + "\");\n";
	}

	file << ""
"while (true) 																							 \n"
"{																										 \n"
"if (PeekMessage(&message, NULL, 0, 0, PM_REMOVE))													  	 \n"
"{																									  	 \n"
"if (message.message == WM_QUIT)																	  	 \n"
"{																								  		 \n"
"break;																						  			 \n"
"}																								  		 \n"
"																										 \n"
"TranslateMessage(&message);																		  	 \n"
"DispatchMessage(&message);																		  		 \n"
"}																									  	 \n"
"																										 \n"
"GetCursorPos(mousePos);																				 \n"
"																										 \n"
"if (mousePos->x >= 0 && mousePos->y >= 0 && mousePos->x <= windowWidth && mousePos->y <= windowHeight)	 \n"
"{																									   	 \n"
"lastMousePosX = mousePos->x;																	  	   	 \n"
"lastMousePosY = mousePos->y;																	  	   	 \n"
"}																									   	 \n"
"																										 \n"
"if (isKeyDown(VK_W))																				   	 \n"
"{																									   	 \n"
"camera->ProcessKeyboard(FORWARD, 0.016f);														  	   	 \n"
"}																									   	 \n"
"																										 \n"
"if (isKeyDown(VK_S))																				   	 \n"
"{																									   	 \n"
"camera->ProcessKeyboard(BACKWARD, 0.016f);														  	   	 \n"
"}																									   	 \n"
"																										 \n"
"if (isKeyDown(VK_A))																				   	 \n"
"{																									   	 \n"
"camera->ProcessKeyboard(LEFT, 0.016f);															  	   	 \n"
"}																									   	 \n"
"																										 \n"
"if (isKeyDown(VK_D))																				   	 \n"
"{																									   	 \n"
"camera->ProcessKeyboard(RIGHT, 0.016f);															  	 \n"
"}																									   	 \n"
"																										 \n"
"if (isKeyDown(VK_ESCAPE))																			   	 \n"
"{																									   	 \n"
"PostQuitMessage(0);																				   	 \n"
"}																									   	 \n"
"																										 \n"
"mouseOffsetX = mousePos->x - lastMousePosX;															 \n"
"mouseOffsetY = lastMousePosY - mousePos->y;															 \n"
"																										 \n"
"lastMousePosX = mousePos->x;																		   	 \n"
"lastMousePosY = mousePos->y;																		   	 \n"
"																										 \n"
"camera->ProcessMouseMovement(mouseOffsetX, mouseOffsetY);											   	 \n"
"																									   	 \n"
"glClearColor(0.1f, 0.3f, 0.8f, 1.f);																	 \n"
"glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);						   	 \n"
"																										 \n"
"glm::mat4 view = glm::mat4(1.0f);																	   	 \n"
"view = camera->GetViewMatrix();																		   	 \n";

	// Вставляем:
	/*
	for i in objects
	{
		for j in i.scripts
		{
			i.j.start();
		}
	}
	*/

	// Метка прорисовки ВСЕХ объектов
	//for (int i = 0; i < (int)object_list.size(); i++)
	//{
	//	object_list[i]->Draw(projection, view, camera->Position);
	//}

	// Метка прорисовки всех объектов
	file << "for (int i = 0; i < gameobject_count; ++i)\n";
	file << "{\n";
	file << "\objects[i]->Draw(projection, view, camera->Position);\n";
	file << "}\n";

	file << ""
"SwapBuffers(hDC);  \n"
"}					\n";

	// Удаление файлов
	for (int i = 0; i < object_list.size(); i++)
	{
		// Вставляем:
		// "delete"
		str = std::to_string(i);
		file << "delete objects[" + str + "];\n";
	}

	file << ""
"delete[] objects;\n"
"delete mousePos;		    \n"
"							\n"
"delete ourShader;			\n"
"delete fontShader;			\n"
"delete selectShader;		\n"
"delete camera;				\n"
"							\n"
"wglMakeCurrent(NULL, NULL);\n"
"wglDeleteContext(hRC);	    \n"
"ReleaseDC(hWndEngine, hDC);\n"
"							\n"
"return 0;				    \n"
"}						    \n";

	file.close();

	str = pathProj + "\\scripts\\bmp.cpp";
	file.open(str);

	file << ""
"#include <fstream>																										 \n"
"#include <cstring>																										 \n"
"#include <string>																										 \n"
"#include <iostream>																									 \n"
"#include <algorithm>																									 \n"
"																														 \n"
"// CIEXYZTRIPLE stuff																									 \n"
"typedef int FXPT2DOT30;																								 \n"
"																														 \n"
"typedef struct {																										 \n"
"FXPT2DOT30 ciexyzX;																									 \n"
"FXPT2DOT30 ciexyzY;																									 \n"
"FXPT2DOT30 ciexyzZ;																									 \n"
"} CIEXYZ;																												 \n"
"																														 \n"
"typedef struct {																										 \n"
"CIEXYZ  ciexyzRed;																										 \n"
"CIEXYZ  ciexyzGreen;																									 \n"
"CIEXYZ  ciexyzBlue;																									 \n"
"} CIEXYZTRIPLE;																										 \n"
"																														 \n"
"// bitmap file header																									 \n"
"typedef struct {																										 \n"
"unsigned short bfType;																									 \n"
"unsigned int   bfSize;																									 \n"
"unsigned short bfReserved1;																							 \n"
"unsigned short bfReserved2;																							 \n"
"unsigned int   bfOffBits;																								 \n"
"} BITMAPFILEHEADER;																									 \n"
"																														 \n"
"// bitmap info header																									 \n"
"typedef struct {																										 \n"
"unsigned int   biSize;																									 \n"
"unsigned int   biWidth;																								 \n"
"unsigned int   biHeight;																								 \n"
"unsigned short biPlanes;																								 \n"
"unsigned short biBitCount;																								 \n"
"unsigned int   biCompression;																							 \n"
"unsigned int   biSizeImage;																							 \n"
"unsigned int   biXPelsPerMeter;																						 \n"
"unsigned int   biYPelsPerMeter;																						 \n"
"unsigned int   biClrUsed;																								 \n"
"unsigned int   biClrImportant;																							 \n"
"unsigned int   biRedMask;																								 \n"
"unsigned int   biGreenMask;																							 \n"
"unsigned int   biBlueMask;																								 \n"
"unsigned int   biAlphaMask;																							 \n"
"unsigned int   biCSType;																								 \n"
"CIEXYZTRIPLE   biEndpoints;																							 \n"
"unsigned int   biGammaRed;																								 \n"
"unsigned int   biGammaGreen;																							 \n"
"unsigned int   biGammaBlue;																							 \n"
"unsigned int   biIntent;																								 \n"
"unsigned int   biProfileData;																							 \n"
"unsigned int   biProfileSize;																							 \n"
"unsigned int   biReserved;																								 \n"
"} BITMAPINFOHEADER;																									 \n"
"																														 \n"
"// rgb quad																											 \n"
"typedef struct {																										 \n"
"unsigned char  rgbBlue;																								 \n"
"unsigned char  rgbGreen;																								 \n"
"unsigned char  rgbRed;																									 \n"
"unsigned char  rgbReserved;																							 \n"
"} RGBQUAD;																												 \n"
"																														 \n"
"unsigned char bitextract(const unsigned int byte, const unsigned int mask);											 \n"
"unsigned char* bmp_reader(const char* fileName, int& h, int& w);														 \n"
"																														 \n"
"// read bytes																											 \n"
"template <typename Type>																								 \n"
"void read(std::ifstream & fp, Type & result, std::size_t size) {														 \n"
"fp.read(reinterpret_cast<char*>(&result), size);																		 \n"
"}																														 \n"
"																														 \n"
"unsigned char* bmp_reader(const char* fileName, int& h, int& w)														 \n"
"{																														 \n"
"																														 \n"
"// открываем файл																										 \n"
"std::ifstream fileStream(fileName, std::ifstream::binary);																 \n"
"if (!fileStream) {																										 \n"
"std::cout << \"Error opening file '\" << fileName << \"'.\" << std::endl;												 \n"
"return 0;																												 \n"
"}																														 \n"
"																														 \n"
"// заголовк изображения																								 \n"
"BITMAPFILEHEADER fileHeader;																							 \n"
"read(fileStream, fileHeader.bfType, sizeof(fileHeader.bfType));														 \n"
"read(fileStream, fileHeader.bfSize, sizeof(fileHeader.bfSize));														 \n"
"read(fileStream, fileHeader.bfReserved1, sizeof(fileHeader.bfReserved1));												 \n"
"read(fileStream, fileHeader.bfReserved2, sizeof(fileHeader.bfReserved2));												 \n"
"read(fileStream, fileHeader.bfOffBits, sizeof(fileHeader.bfOffBits));													 \n"
"																														 \n"
"if (fileHeader.bfType != 0x4D42) {																						 \n"
"std::cout << \"Error: '\" << fileName << \"' is not BMP file.\" << std::endl;											 \n"
"return 0;																												 \n"
"}																														 \n"
"																														 \n"
"// информация изображения																								 \n"
"BITMAPINFOHEADER fileInfoHeader;																						 \n"
"read(fileStream, fileInfoHeader.biSize, sizeof(fileInfoHeader.biSize));												 \n"
"																														 \n"
"// bmp core																											 \n"
"if (fileInfoHeader.biSize >= 12) {																						 \n"
"read(fileStream, fileInfoHeader.biWidth, sizeof(fileInfoHeader.biWidth));												 \n"
"read(fileStream, fileInfoHeader.biHeight, sizeof(fileInfoHeader.biHeight));											 \n"
"read(fileStream, fileInfoHeader.biPlanes, sizeof(fileInfoHeader.biPlanes));											 \n"
"read(fileStream, fileInfoHeader.biBitCount, sizeof(fileInfoHeader.biBitCount));										 \n"
"}																														 \n"
"																														 \n"
"// получаем информацию о битности																						 \n"
"int colorsCount = fileInfoHeader.biBitCount >> 3;																		 \n"
"if (colorsCount < 3) {																									 \n"
"colorsCount = 3;																										 \n"
"}																														 \n"
"																														 \n"
"int bitsOnColor = fileInfoHeader.biBitCount / colorsCount;																 \n"
"int maskValue = (1 << bitsOnColor) - 1;																				 \n"
"																														 \n"
"// bmp v1																												 \n"
"if (fileInfoHeader.biSize >= 40) {																						 \n"
"read(fileStream, fileInfoHeader.biCompression, sizeof(fileInfoHeader.biCompression));									 \n"
"read(fileStream, fileInfoHeader.biSizeImage, sizeof(fileInfoHeader.biSizeImage));										 \n"
"read(fileStream, fileInfoHeader.biXPelsPerMeter, sizeof(fileInfoHeader.biXPelsPerMeter));								 \n"
"read(fileStream, fileInfoHeader.biYPelsPerMeter, sizeof(fileInfoHeader.biYPelsPerMeter));								 \n"
"read(fileStream, fileInfoHeader.biClrUsed, sizeof(fileInfoHeader.biClrUsed));											 \n"
"read(fileStream, fileInfoHeader.biClrImportant, sizeof(fileInfoHeader.biClrImportant));								 \n"
"}																														 \n"
"																														 \n"
"// bmp v2																												 \n"
"fileInfoHeader.biRedMask = 0;																							 \n"
"fileInfoHeader.biGreenMask = 0;																						 \n"
"fileInfoHeader.biBlueMask = 0;																							 \n"
"																														 \n"
"if (fileInfoHeader.biSize >= 52) {																						 \n"
"read(fileStream, fileInfoHeader.biRedMask, sizeof(fileInfoHeader.biRedMask));											 \n"
"read(fileStream, fileInfoHeader.biGreenMask, sizeof(fileInfoHeader.biGreenMask));										 \n"
"read(fileStream, fileInfoHeader.biBlueMask, sizeof(fileInfoHeader.biBlueMask));										 \n"
"}																														 \n"
"																														 \n"
"// если маска не задана, то ставим маску по умолчанию																	 \n"
"if (fileInfoHeader.biRedMask == 0 || fileInfoHeader.biGreenMask == 0 || fileInfoHeader.biBlueMask == 0) {				 \n"
"fileInfoHeader.biRedMask = maskValue << (bitsOnColor * 2);																 \n"
"fileInfoHeader.biGreenMask = maskValue << bitsOnColor;																	 \n"
"fileInfoHeader.biBlueMask = maskValue;																					 \n"
"}																														 \n"
"																														 \n"
"// bmp v3																												 \n"
"if (fileInfoHeader.biSize >= 56) {																						 \n"
"read(fileStream, fileInfoHeader.biAlphaMask, sizeof(fileInfoHeader.biAlphaMask));										 \n"
"}																														 \n"
"else {																													 \n"
"fileInfoHeader.biAlphaMask = maskValue << (bitsOnColor * 3);															 \n"
"}																														 \n"
"																														 \n"
"// bmp v4																												 \n"
"if (fileInfoHeader.biSize >= 108) {																					 \n"
"read(fileStream, fileInfoHeader.biCSType, sizeof(fileInfoHeader.biCSType));											 \n"
"read(fileStream, fileInfoHeader.biEndpoints, sizeof(fileInfoHeader.biEndpoints));										 \n"
"read(fileStream, fileInfoHeader.biGammaRed, sizeof(fileInfoHeader.biGammaRed));										 \n"
"read(fileStream, fileInfoHeader.biGammaGreen, sizeof(fileInfoHeader.biGammaGreen));									 \n"
"read(fileStream, fileInfoHeader.biGammaBlue, sizeof(fileInfoHeader.biGammaBlue));										 \n"
"}																														 \n"
"																														 \n"
"// bmp v5																												 \n"
"if (fileInfoHeader.biSize >= 124) {																					 \n"
"read(fileStream, fileInfoHeader.biIntent, sizeof(fileInfoHeader.biIntent));											 \n"
"read(fileStream, fileInfoHeader.biProfileData, sizeof(fileInfoHeader.biProfileData));									 \n"
"read(fileStream, fileInfoHeader.biProfileSize, sizeof(fileInfoHeader.biProfileSize));									 \n"
"read(fileStream, fileInfoHeader.biReserved, sizeof(fileInfoHeader.biReserved));										 \n"
"}																														 \n"
"																														 \n"
"// проверка на поддерку этой версии формата																			 \n"
"if (fileInfoHeader.biSize != 12 && fileInfoHeader.biSize != 40 && fileInfoHeader.biSize != 52 &&						 \n"
"fileInfoHeader.biSize != 56 && fileInfoHeader.biSize != 108 && fileInfoHeader.biSize != 124) {							 \n"
"std::cout << \"Error: Unsupported BMP format.\" << std::endl;															 \n"
"return 0;																												 \n"
"}																														 \n"
"																														 \n"
"if (fileInfoHeader.biBitCount != 16 && fileInfoHeader.biBitCount != 24 && fileInfoHeader.biBitCount != 32) {			 \n"
"std::cout << \"Error: Unsupported BMP bit count.\" << std::endl;														 \n"
"return 0;																												 \n"
"}																														 \n"
"																														 \n"
"if (fileInfoHeader.biCompression != 0 && fileInfoHeader.biCompression != 3) {											 \n"
"std::cout << \"Error: Unsupported BMP compression.\" << std::endl;														 \n"
"return 0;																												 \n"
"}																														 \n"
"																														 \n"
"// rgb info																											 \n"
"RGBQUAD** rgbInfo = new RGBQUAD * [fileInfoHeader.biHeight];															 \n"
"																														 \n"
"for (unsigned int i = 0; i < fileInfoHeader.biHeight; i++) {															 \n"
"rgbInfo[i] = new RGBQUAD[fileInfoHeader.biWidth];																		 \n"
"}																														 \n"
"																														 \n"
"// определение размера отступа в конце каждой строки																	 \n"
"int linePadding = ((fileInfoHeader.biWidth * (fileInfoHeader.biBitCount / 8)) % 4) & 3;								 \n"
"																														 \n"
"// чтение																												 \n"
"unsigned int bufer;																									 \n"
"																														 \n"
"for (unsigned int i = 0; i < fileInfoHeader.biHeight; i++) {															 \n"
"for (unsigned int j = 0; j < fileInfoHeader.biWidth; j++) {															 \n"
"read(fileStream, bufer, fileInfoHeader.biBitCount / 8);																 \n"
"																														 \n"
"rgbInfo[i][j].rgbRed = bitextract(bufer, fileInfoHeader.biRedMask);													 \n"
"rgbInfo[i][j].rgbGreen = bitextract(bufer, fileInfoHeader.biGreenMask);												 \n"
"rgbInfo[i][j].rgbBlue = bitextract(bufer, fileInfoHeader.biBlueMask);													 \n"
"rgbInfo[i][j].rgbReserved = bitextract(bufer, fileInfoHeader.biAlphaMask);												 \n"
"}																														 \n"
"fileStream.seekg(linePadding, std::ios_base::cur);																		 \n"
"}																														 \n"
"																														 \n"
"w = fileInfoHeader.biWidth;																							 \n"
"h = fileInfoHeader.biHeight;																							 \n"
"																														 \n"
"																														 \n"
"unsigned char* out = new unsigned char[w * h * 4];																		 \n"
"int n = 0;																												 \n"
"																														 \n"
"// вывод																												 \n"
"for (unsigned int i = 0; i < fileInfoHeader.biHeight; i++) {															 \n"
"for (unsigned int j = 0; j < fileInfoHeader.biWidth; j++) {															 \n"
"out[n] = rgbInfo[i][j].rgbRed;																							 \n"
"out[n + 1] = rgbInfo[i][j].rgbGreen;																					 \n"
"out[n + 2] = rgbInfo[i][j].rgbBlue;																					 \n"
"out[n + 3] = rgbInfo[i][j].rgbReserved;																				 \n"
"																														 \n"
"++n;																													 \n"
"++n;																													 \n"
"++n;																													 \n"
"++n;																													 \n"
"																														 \n"
"/*std::cout << std::hex																								 \n"
"<< +rgbInfo[i][j].rgbRed << \" \"																						 \n"
"<< +rgbInfo[i][j].rgbGreen << \" \"																					 \n"
"<< +rgbInfo[i][j].rgbBlue << \" \"																						 \n"
"<< +rgbInfo[i][j].rgbReserved																							 \n"
"<< std::endl;*/																										 \n"
"																														 \n"
"																														 \n"
"}																														 \n"
"}																														 \n"
"return out;																											 \n"
"}																														 \n"
"																														 \n"
"unsigned char bitextract(const unsigned int byte, const unsigned int mask) {											 \n"
"if (mask == 0) {																										 \n"
"return 0;																												 \n"
"}																														 \n"
"																														 \n"
"// определение количества нулевых бит справа от маски																	 \n"
"int																													 \n"
"maskBufer = mask,																										 \n"
"maskPadding = 0;																										 \n"
"																														 \n"
"while (!(maskBufer & 1)) {																								 \n"
"maskBufer >>= 1;																										 \n"
"maskPadding++;																											 \n"
"}																														 \n"
"																														 \n"
"// применение маски и смещение																							 \n"
"return (byte & mask) >> maskPadding;																					 \n"
"}																														 \n";

	file.close();

	str = pathProj + "\\scripts\\bmp.h";
	file.open(str);

	file << ""
"#pragma once													  \n"
"																  \n"
"unsigned char* bmp_reader(const char* fileName, int& h, int& w); \n";

	file.close();

 	return 0;
}
